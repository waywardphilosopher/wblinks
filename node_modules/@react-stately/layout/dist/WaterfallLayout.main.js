var $5TwTj$reactstatelyvirtualizer = require("@react-stately/virtualizer");


function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "WaterfallLayout", () => $f2cd6b90da09fa37$export$e9f7cda058ba8df8);
/*
 * Copyright 2024 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
class $f2cd6b90da09fa37$var$WaterfallLayoutInfo extends (0, $5TwTj$reactstatelyvirtualizer.LayoutInfo) {
    copy() {
        let res = super.copy();
        res.column = this.column;
        return res;
    }
    constructor(...args){
        super(...args), this.column = 0;
    }
}
const $f2cd6b90da09fa37$var$DEFAULT_OPTIONS = {
    minItemSize: new (0, $5TwTj$reactstatelyvirtualizer.Size)(200, 200),
    maxItemSize: new (0, $5TwTj$reactstatelyvirtualizer.Size)(Infinity, Infinity),
    minSpace: new (0, $5TwTj$reactstatelyvirtualizer.Size)(18, 18),
    maxColumns: Infinity,
    dropIndicatorThickness: 2
};
class $f2cd6b90da09fa37$export$e9f7cda058ba8df8 extends (0, $5TwTj$reactstatelyvirtualizer.Layout) {
    shouldInvalidateLayoutOptions(newOptions, oldOptions) {
        return newOptions.maxColumns !== oldOptions.maxColumns || newOptions.dropIndicatorThickness !== oldOptions.dropIndicatorThickness || !(newOptions.minItemSize || $f2cd6b90da09fa37$var$DEFAULT_OPTIONS.minItemSize).equals(oldOptions.minItemSize || $f2cd6b90da09fa37$var$DEFAULT_OPTIONS.minItemSize) || !(newOptions.maxItemSize || $f2cd6b90da09fa37$var$DEFAULT_OPTIONS.maxItemSize).equals(oldOptions.maxItemSize || $f2cd6b90da09fa37$var$DEFAULT_OPTIONS.maxItemSize) || !(newOptions.minSpace || $f2cd6b90da09fa37$var$DEFAULT_OPTIONS.minSpace).equals(oldOptions.minSpace || $f2cd6b90da09fa37$var$DEFAULT_OPTIONS.minSpace);
    }
    update(invalidationContext) {
        let { minItemSize: minItemSize = $f2cd6b90da09fa37$var$DEFAULT_OPTIONS.minItemSize, maxItemSize: maxItemSize = $f2cd6b90da09fa37$var$DEFAULT_OPTIONS.maxItemSize, minSpace: minSpace = $f2cd6b90da09fa37$var$DEFAULT_OPTIONS.minSpace, maxColumns: maxColumns = $f2cd6b90da09fa37$var$DEFAULT_OPTIONS.maxColumns, dropIndicatorThickness: dropIndicatorThickness = $f2cd6b90da09fa37$var$DEFAULT_OPTIONS.dropIndicatorThickness } = invalidationContext.layoutOptions || {};
        this.dropIndicatorThickness = dropIndicatorThickness;
        let visibleWidth = this.virtualizer.visibleRect.width;
        // The max item width is always the entire viewport.
        // If the max item height is infinity, scale in proportion to the max width.
        let maxItemWidth = Math.min(maxItemSize.width, visibleWidth);
        let maxItemHeight = Number.isFinite(maxItemSize.height) ? maxItemSize.height : Math.floor(minItemSize.height / minItemSize.width * maxItemWidth);
        // Compute the number of rows and columns needed to display the content
        let columns = Math.floor(visibleWidth / (minItemSize.width + minSpace.width));
        let numColumns = Math.max(1, Math.min(maxColumns, columns));
        // Compute the available width (minus the space between items)
        let width = visibleWidth - minSpace.width * Math.max(0, numColumns);
        // Compute the item width based on the space available
        let itemWidth = Math.floor(width / numColumns);
        itemWidth = Math.max(minItemSize.width, Math.min(maxItemWidth, itemWidth));
        // Compute the item height, which is proportional to the item width
        let t = (itemWidth - minItemSize.width) / Math.max(1, maxItemWidth - minItemSize.width);
        let itemHeight = minItemSize.height + Math.floor((maxItemHeight - minItemSize.height) * t);
        itemHeight = Math.max(minItemSize.height, Math.min(maxItemHeight, itemHeight));
        // Compute the horizontal spacing and content height
        let horizontalSpacing = Math.floor((visibleWidth - numColumns * itemWidth) / (numColumns + 1));
        // Setup an array of column heights
        let columnHeights = Array(numColumns).fill(minSpace.height);
        let newLayoutInfos = new Map();
        let addNode = (key, node)=>{
            let oldLayoutInfo = this.layoutInfos.get(key);
            let height = itemHeight;
            let estimatedSize = true;
            if (oldLayoutInfo) {
                height = oldLayoutInfo.rect.height;
                estimatedSize = invalidationContext.sizeChanged || oldLayoutInfo.estimatedSize || oldLayoutInfo.content !== node;
            }
            // Figure out which column to place the item in, and compute its position.
            // Preserve the previous column index so items don't jump around during resizing unless the number of columns changed.
            let prevColumn = numColumns === this.numColumns && oldLayoutInfo && oldLayoutInfo.rect.y < this.virtualizer.visibleRect.maxY ? oldLayoutInfo.column : undefined;
            let column = prevColumn !== null && prevColumn !== void 0 ? prevColumn : columnHeights.reduce((minIndex, h, i)=>h < columnHeights[minIndex] ? i : minIndex, 0);
            let x = horizontalSpacing + column * (itemWidth + horizontalSpacing);
            let y = columnHeights[column];
            let rect = new (0, $5TwTj$reactstatelyvirtualizer.Rect)(x, y, itemWidth, height);
            let layoutInfo = new $f2cd6b90da09fa37$var$WaterfallLayoutInfo(node.type, key, rect);
            layoutInfo.estimatedSize = estimatedSize;
            layoutInfo.allowOverflow = true;
            layoutInfo.content = node;
            layoutInfo.column = column;
            newLayoutInfos.set(key, layoutInfo);
            columnHeights[column] += layoutInfo.rect.height + minSpace.height;
        };
        let skeletonCount = 0;
        for (let node of this.virtualizer.collection)if (node.type === 'skeleton') {
            // Add skeleton cards until every column has at least one, and we fill the viewport.
            let startingHeights = [
                ...columnHeights
            ];
            while(!columnHeights.every((h, i)=>h !== startingHeights[i]) || Math.min(...columnHeights) < this.virtualizer.visibleRect.height){
                var _this_layoutInfos_get;
                let key = `${node.key}-${skeletonCount++}`;
                let content = ((_this_layoutInfos_get = this.layoutInfos.get(key)) === null || _this_layoutInfos_get === void 0 ? void 0 : _this_layoutInfos_get.content) || {
                    ...node
                };
                addNode(key, content);
            }
            break;
        } else addNode(node.key, node);
        // Reset all columns to the maximum for the next section
        let maxHeight = Math.max(...columnHeights);
        this.contentSize = new (0, $5TwTj$reactstatelyvirtualizer.Size)(this.virtualizer.visibleRect.width, maxHeight);
        this.layoutInfos = newLayoutInfos;
        this.numColumns = numColumns;
    }
    getLayoutInfo(key) {
        return this.layoutInfos.get(key);
    }
    getContentSize() {
        return this.contentSize;
    }
    getVisibleLayoutInfos(rect) {
        let layoutInfos = [];
        for (let layoutInfo of this.layoutInfos.values())if (layoutInfo.rect.intersects(rect) || this.virtualizer.isPersistedKey(layoutInfo.key)) layoutInfos.push(layoutInfo);
        return layoutInfos;
    }
    updateItemSize(key, size) {
        let layoutInfo = this.layoutInfos.get(key);
        if (!size || !layoutInfo) return false;
        if (size.height !== layoutInfo.rect.height) {
            let newLayoutInfo = layoutInfo.copy();
            newLayoutInfo.rect.height = size.height;
            newLayoutInfo.estimatedSize = false;
            this.layoutInfos.set(key, newLayoutInfo);
            return true;
        }
        return false;
    }
    // Override keyboard navigation to work spatially.
    getKeyRightOf(key) {
        let layoutInfo = this.getLayoutInfo(key);
        if (!layoutInfo) return null;
        let rect = new (0, $5TwTj$reactstatelyvirtualizer.Rect)(layoutInfo.rect.maxX, layoutInfo.rect.y, this.virtualizer.visibleRect.maxX - layoutInfo.rect.maxX, layoutInfo.rect.height);
        let layoutInfos = this.getVisibleLayoutInfos(rect);
        let bestKey = null;
        let bestDistance = Infinity;
        for (let candidate of layoutInfos){
            if (candidate.key === key) continue;
            // Find the closest item in the x direction with the most overlap in the y direction.
            let deltaX = candidate.rect.x - rect.x;
            let overlapY = Math.min(candidate.rect.maxY, rect.maxY) - Math.max(candidate.rect.y, rect.y);
            let distance = deltaX - overlapY;
            if (distance < bestDistance) {
                bestDistance = distance;
                bestKey = candidate.key;
            }
        }
        return bestKey;
    }
    getKeyLeftOf(key) {
        let layoutInfo = this.getLayoutInfo(key);
        if (!layoutInfo) return null;
        let rect = new (0, $5TwTj$reactstatelyvirtualizer.Rect)(0, layoutInfo.rect.y, layoutInfo.rect.x, layoutInfo.rect.height);
        let layoutInfos = this.getVisibleLayoutInfos(rect);
        let bestKey = null;
        let bestDistance = Infinity;
        for (let candidate of layoutInfos){
            if (candidate.key === key) continue;
            // Find the closest item in the x direction with the most overlap in the y direction.
            let deltaX = rect.maxX - candidate.rect.maxX;
            let overlapY = Math.min(candidate.rect.maxY, rect.maxY) - Math.max(candidate.rect.y, rect.y);
            let distance = deltaX - overlapY;
            if (distance < bestDistance) {
                bestDistance = distance;
                bestKey = candidate.key;
            }
        }
        return bestKey;
    }
    // This overrides the default behavior of shift selection to work spatially
    // rather than following the order of the items in the collection (which may appear unpredictable).
    getKeyRange(from, to) {
        let fromLayoutInfo = this.getLayoutInfo(from);
        let toLayoutInfo = this.getLayoutInfo(to);
        if (!fromLayoutInfo || !toLayoutInfo) return [];
        // Find items where half of the area intersects the rectangle
        // formed from the first item to the last item in the range.
        let rect = fromLayoutInfo.rect.union(toLayoutInfo.rect);
        let keys = [];
        for (let layoutInfo of this.layoutInfos.values())if (rect.intersection(layoutInfo.rect).area > layoutInfo.rect.area / 2) keys.push(layoutInfo.key);
        return keys;
    }
    getDropTargetFromPoint(x, y) {
        if (this.layoutInfos.size === 0) return {
            type: 'root'
        };
        x += this.virtualizer.visibleRect.x;
        y += this.virtualizer.visibleRect.y;
        let key = this.virtualizer.keyAtPoint(new (0, $5TwTj$reactstatelyvirtualizer.Point)(x, y));
        if (key == null) return {
            type: 'root'
        };
        // Only support "on" drop position in waterfall layout.
        // Reordering doesn't make sense because the items don't have a deterministic order.
        return {
            type: 'item',
            key: key,
            dropPosition: 'on'
        };
    }
    constructor(...args){
        super(...args), this.contentSize = new (0, $5TwTj$reactstatelyvirtualizer.Size)(), this.layoutInfos = new Map(), this.numColumns = 0, this.dropIndicatorThickness = 2;
    }
}


//# sourceMappingURL=WaterfallLayout.main.js.map
