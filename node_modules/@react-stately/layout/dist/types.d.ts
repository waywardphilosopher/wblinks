import { DropTarget, DropTargetDelegate, ItemDropTarget, Key, Node, Collection, LayoutDelegate } from "@react-types/shared";
import { InvalidationContext, Layout, LayoutInfo, Rect, Size } from "@react-stately/virtualizer";
import { GridNode } from "@react-types/grid";
import { TableCollection } from "@react-types/table";
export interface GridLayoutOptions {
    /**
     * The minimum item size.
     * @default 200 x 200
     */
    minItemSize?: Size;
    /**
     * The maximum item size.
     * @default Infinity
     */
    maxItemSize?: Size;
    /**
     * Whether to preserve the aspect ratio of the `minItemSize`.
     * By default, grid rows may have variable heights. When `preserveAspectRatio`
     * is true, all rows will have equal heights.
     * @default false
     */
    preserveAspectRatio?: boolean;
    /**
     * The minimum space required between items.
     * @default 18 x 18
     */
    minSpace?: Size;
    /**
     * The maximum number of columns.
     * @default Infinity
     */
    maxColumns?: number;
    /**
     * The thickness of the drop indicator.
     * @default 2
     */
    dropIndicatorThickness?: number;
}
/**
 * GridLayout is a virtualizer Layout implementation
 * that arranges its items in a grid.
 * The items are sized between a minimum and maximum size
 * depending on the width of the container.
 */
export class GridLayout<T, O extends GridLayoutOptions = GridLayoutOptions> extends Layout<Node<T>, O> implements DropTargetDelegate {
    protected gap: Size;
    protected dropIndicatorThickness: number;
    protected numColumns: number;
    shouldInvalidateLayoutOptions(newOptions: O, oldOptions: O): boolean;
    update(invalidationContext: InvalidationContext<O>): void;
    getLayoutInfo(key: Key): LayoutInfo | null;
    getContentSize(): Size;
    getVisibleLayoutInfos(rect: Rect): LayoutInfo[];
    updateItemSize(key: Key, size: Size): boolean;
    getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget;
    getDropTargetLayoutInfo(target: ItemDropTarget): LayoutInfo;
}
export interface ListLayoutOptions {
    /**
     * The fixed height of a row in px.
     * @default 48
     */
    rowHeight?: number;
    /** The estimated height of a row, when row heights are variable. */
    estimatedRowHeight?: number;
    /**
     * The fixed height of a section header in px.
     * @default 48
     */
    headingHeight?: number;
    /** The estimated height of a section header, when the height is variable. */
    estimatedHeadingHeight?: number;
    /**
     * The fixed height of a loader element in px. This loader is specifically for
     * "load more" elements rendered when loading more rows at the root level or inside nested row/sections.
     * @default 48
     */
    loaderHeight?: number;
    /**
     * The thickness of the drop indicator.
     * @default 2
     */
    dropIndicatorThickness?: number;
    /**
     * The gap between items.
     * @default 0
     */
    gap?: number;
    /**
     * The padding around the list.
     * @default 0
     */
    padding?: number;
}
export interface LayoutNode {
    node?: Node<unknown>;
    layoutInfo: LayoutInfo;
    children?: LayoutNode[];
    validRect: Rect;
    index?: number;
}
/**
 * ListLayout is a virtualizer Layout implementation
 * that arranges its items in a vertical stack. It supports both fixed
 * and variable height items.
 */
export class ListLayout<T, O extends ListLayoutOptions = ListLayoutOptions> extends Layout<Node<T>, O> implements DropTargetDelegate {
    protected rowHeight: number | null;
    protected estimatedRowHeight: number | null;
    protected headingHeight: number | null;
    protected estimatedHeadingHeight: number | null;
    protected loaderHeight: number | null;
    protected dropIndicatorThickness: number;
    protected gap: number;
    protected padding: number;
    protected layoutNodes: Map<Key, LayoutNode>;
    protected contentSize: Size;
    protected lastCollection: Collection<Node<T>> | null;
    protected rootNodes: LayoutNode[];
    /** The rectangle containing currently valid layout infos. */
    protected validRect: Rect;
    /** The rectangle of requested layout infos so far. */
    protected requestedRect: Rect;
    /**
     * Creates a new ListLayout with options. See the list of properties below for a description
     * of the options that can be provided.
     */
    constructor(options?: ListLayoutOptions);
    protected get collection(): Collection<Node<T>>;
    getLayoutInfo(key: Key): LayoutInfo | null;
    getVisibleLayoutInfos(rect: Rect): LayoutInfo[];
    protected layoutIfNeeded(rect: Rect): void;
    protected isVisible(node: LayoutNode, rect: Rect): boolean;
    protected shouldInvalidateEverything(invalidationContext: InvalidationContext<O>): boolean;
    shouldInvalidateLayoutOptions(newOptions: O, oldOptions: O): boolean;
    update(invalidationContext: InvalidationContext<O>): void;
    protected buildCollection(y?: number): LayoutNode[];
    protected isValid(node: Node<T>, y: number): boolean;
    protected buildChild(node: Node<T>, x: number, y: number, parentKey: Key | null): LayoutNode;
    protected buildNode(node: Node<T>, x: number, y: number): LayoutNode;
    protected buildLoader(node: Node<T>, x: number, y: number): LayoutNode;
    protected buildSection(node: Node<T>, x: number, y: number): LayoutNode;
    protected buildSectionHeader(node: Node<T>, x: number, y: number): LayoutNode;
    protected buildItem(node: Node<T>, x: number, y: number): LayoutNode;
    updateItemSize(key: Key, size: Size): boolean;
    getContentSize(): Size;
    getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget | null;
    getDropTargetLayoutInfo(target: ItemDropTarget): LayoutInfo;
}
export interface TableLayoutProps extends ListLayoutOptions {
    columnWidths?: Map<Key, number>;
}
/**
 * TableLayout is a virtualizer Layout implementation that arranges
 * items in rows and columns.
 */
export class TableLayout<T, O extends TableLayoutProps = TableLayoutProps> extends ListLayout<T, O> {
    protected lastCollection: TableCollection<T> | null;
    constructor(options?: ListLayoutOptions);
    protected get collection(): TableCollection<T>;
    shouldInvalidateLayoutOptions(newOptions: O, oldOptions: O): boolean;
    update(invalidationContext: InvalidationContext<O>): void;
    protected buildCollection(): LayoutNode[];
    protected buildTableHeader(): LayoutNode;
    protected buildHeaderRow(headerRow: GridNode<T>, x: number, y: number): LayoutNode;
    protected getEstimatedRowHeight(): number;
    protected buildColumn(node: GridNode<T>, x: number, y: number): LayoutNode;
    protected isStickyColumn(node: GridNode<T>): boolean;
    protected buildBody(y: number): LayoutNode;
    protected buildNode(node: GridNode<T>, x: number, y: number): LayoutNode;
    protected buildRow(node: GridNode<T>, x: number, y: number): LayoutNode;
    protected buildCell(node: GridNode<T>, x: number, y: number): LayoutNode;
    getVisibleLayoutInfos(rect: Rect): LayoutInfo[];
    getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget | null;
    getDropTargetLayoutInfo(target: ItemDropTarget): LayoutInfo;
}
export interface WaterfallLayoutOptions {
    /**
     * The minimum item size.
     * @default 200 x 200
     */
    minItemSize?: Size;
    /**
     * The maximum item size.
     * @default Infinity
     */
    maxItemSize?: Size;
    /**
     * The minimum space required between items.
     * @default 18 x 18
     */
    minSpace?: Size;
    /**
     * The maximum number of columns.
     * @default Infinity
     */
    maxColumns?: number;
    /**
     * The thickness of the drop indicator.
     * @default 2
     */
    dropIndicatorThickness?: number;
}
export class WaterfallLayout<T extends object, O extends WaterfallLayoutOptions = WaterfallLayoutOptions> extends Layout<Node<T>, O> implements LayoutDelegate, DropTargetDelegate {
    protected numColumns: number;
    protected dropIndicatorThickness: number;
    shouldInvalidateLayoutOptions(newOptions: O, oldOptions: O): boolean;
    update(invalidationContext: InvalidationContext<O>): void;
    getLayoutInfo(key: Key): LayoutInfo;
    getContentSize(): Size;
    getVisibleLayoutInfos(rect: Rect): LayoutInfo[];
    updateItemSize(key: Key, size: Size): boolean;
    getKeyRightOf(key: Key): Key | null;
    getKeyLeftOf(key: Key): Key | null;
    getKeyRange(from: Key, to: Key): Key[];
    getDropTargetFromPoint(x: number, y: number): DropTarget;
}

//# sourceMappingURL=types.d.ts.map
