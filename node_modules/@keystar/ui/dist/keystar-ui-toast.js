'use client';
import { c } from './react-compiler-runtime-19061925.js';
import { useToastQueue, ToastQueue } from '@react-stately/toast';
import { forwardRef, useRef, useEffect, useSyncExternalStore } from 'react';
import { warning } from 'emery';
import { useLocalizedStringFormatter, useLocale } from '@react-aria/i18n';
import { useToast, useToastRegion } from '@react-aria/toast';
import { useObjectRef } from '@react-aria/utils';
import { ClearButton, Button } from '@keystar/ui/button';
import { Icon } from '@keystar/ui/icon';
import { checkCircle2Icon } from '@keystar/ui/icon/icons/checkCircle2Icon';
import { infoIcon } from '@keystar/ui/icon/icons/infoIcon';
import { alertTriangleIcon } from '@keystar/ui/icon/icons/alertTriangleIcon';
import { SlotProvider } from '@keystar/ui/slots';
import { useStyleProps, classNames, css, tokenSchema, useIsMobileDevice, FocusRing } from '@keystar/ui/style';
import { Text } from '@keystar/ui/typography';
import { isReactText } from '@keystar/ui/utils';
import { jsx, jsxs } from 'react/jsx-runtime';
import ReactDOM from 'react-dom';
import { KeystarProvider } from '@keystar/ui/core';

const localizedMessages = {
  "ar-AE": {
    "info": `معلومات`,
    "critical": `خطأ`,
    "positive": `تم بنجاح`
  },
  "bg-BG": {
    "info": `Инфо`,
    "critical": `Грешка`,
    "positive": `Успех`
  },
  "cs-CZ": {
    "info": `Informace`,
    "critical": `Chyba`,
    "positive": `Úspěch`
  },
  "da-DK": {
    "info": `Info`,
    "critical": `Fejl`,
    "positive": `Fuldført`
  },
  "de-DE": {
    "info": `Informationen`,
    "critical": `Fehler`,
    "positive": `Erfolg`
  },
  "el-GR": {
    "info": `Πληροφορίες`,
    "critical": `Σφάλμα`,
    "positive": `Επιτυχία`
  },
  "en-US": {
    "info": `Info`,
    "critical": `Error`,
    "positive": `Success`
  },
  "es-ES": {
    "info": `Información`,
    "critical": `Error`,
    "positive": `Éxito`
  },
  "et-EE": {
    "info": `Teave`,
    "critical": `Viga`,
    "positive": `Valmis`
  },
  "fi-FI": {
    "info": `Tiedot`,
    "critical": `Virhe`,
    "positive": `Onnistui`
  },
  "fr-FR": {
    "info": `Infos`,
    "critical": `Erreur`,
    "positive": `Succès`
  },
  "he-IL": {
    "info": `מידע`,
    "critical": `שגיאה`,
    "positive": `הצלחה`
  },
  "hr-HR": {
    "info": `Informacije`,
    "critical": `Pogreška`,
    "positive": `Uspješno`
  },
  "hu-HU": {
    "info": `Információ`,
    "critical": `Hiba`,
    "positive": `Siker`
  },
  "it-IT": {
    "info": `Informazioni`,
    "critical": `Errore`,
    "positive": `Operazione riuscita`
  },
  "ja-JP": {
    "info": `情報`,
    "critical": `エラー`,
    "positive": `成功`
  },
  "ko-KR": {
    "info": `정보`,
    "critical": `오류`,
    "positive": `성공`
  },
  "lt-LT": {
    "info": `Informacija`,
    "critical": `Klaida`,
    "positive": `Sėkmingai`
  },
  "lv-LV": {
    "info": `Informācija`,
    "critical": `Kļūda`,
    "positive": `Izdevās`
  },
  "nb-NO": {
    "info": `Info`,
    "critical": `Feil`,
    "positive": `Vellykket`
  },
  "nl-NL": {
    "info": `Info`,
    "critical": `Fout`,
    "positive": `Geslaagd`
  },
  "pl-PL": {
    "info": `Informacje`,
    "critical": `Błąd`,
    "positive": `Powodzenie`
  },
  "pt-BR": {
    "info": `Informações`,
    "critical": `Erro`,
    "positive": `Sucesso`
  },
  "pt-PT": {
    "info": `Informação`,
    "critical": `Erro`,
    "positive": `Sucesso`
  },
  "ro-RO": {
    "info": `Informaţii`,
    "critical": `Eroare`,
    "positive": `Succes`
  },
  "ru-RU": {
    "info": `Информация`,
    "critical": `Ошибка`,
    "positive": `Успешно`
  },
  "sk-SK": {
    "info": `Informácie`,
    "critical": `Chyba`,
    "positive": `Úspech`
  },
  "sl-SI": {
    "info": `Informacije`,
    "critical": `Napaka`,
    "positive": `Uspešno`
  },
  "sr-SP": {
    "info": `Informacije`,
    "critical": `Greška`,
    "positive": `Uspešno`
  },
  "sv-SE": {
    "info": `Info`,
    "critical": `Fel`,
    "positive": `Lyckades`
  },
  "tr-TR": {
    "info": `Bilgiler`,
    "critical": `Hata`,
    "positive": `Başarılı`
  },
  "uk-UA": {
    "info": `Інформація`,
    "critical": `Помилка`,
    "positive": `Успішно`
  },
  "zh-CN": {
    "info": `信息`,
    "critical": `错误`,
    "positive": `成功`
  },
  "zh-TW": {
    "info": `資訊`,
    "critical": `錯誤`,
    "positive": `成功`
  }
};

const ICONS = {
  info: infoIcon,
  critical: alertTriangleIcon,
  // neutral: infoIcon,
  positive: checkCircle2Icon
};
function Toast(props, ref) {
  const $ = c(49);
  let t0;
  let state;
  let otherProps;
  if ($[0] !== props) {
    ({
      toast: t0,
      state,
      ...otherProps
    } = props);
    $[0] = props;
    $[1] = t0;
    $[2] = state;
    $[3] = otherProps;
  } else {
    t0 = $[1];
    state = $[2];
    otherProps = $[3];
  }
  const {
    key,
    content: t1
  } = t0;
  const {
    children,
    tone,
    actionLabel,
    onAction,
    shouldCloseOnAction
  } = t1;
  const domRef = useObjectRef(ref);
  const {
    closeButtonProps,
    titleProps,
    toastProps,
    contentProps
  } = useToast(props, state, domRef);
  const styleProps = useStyleProps(otherProps);
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  let t2;
  if ($[4] !== tone || $[5] !== stringFormatter) {
    t2 = tone && tone !== "neutral" ? stringFormatter.format(tone) : null;
    $[4] = tone;
    $[5] = stringFormatter;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  const iconLabel = t2;
  const icon = tone && tone !== "neutral" ? ICONS[tone] : null;
  let t3;
  if ($[7] !== onAction || $[8] !== shouldCloseOnAction || $[9] !== state || $[10] !== key) {
    t3 = () => {
      if (onAction) {
        onAction();
      }
      if (shouldCloseOnAction) {
        state.close(key);
      }
    };
    $[7] = onAction;
    $[8] = shouldCloseOnAction;
    $[9] = state;
    $[10] = key;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  const handleAction = t3;
  let t4;
  let t5;
  if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = {
      text: {
        color: "inherit"
      }
    };
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  t4 = t5;
  const slots = t4;
  let t6;
  if ($[13] !== styleProps.className) {
    t6 = classNames(css({
      borderRadius: tokenSchema.size.radius.regular,
      display: "flex",
      margin: tokenSchema.size.space.large,
      maxWidth: tokenSchema.size.container.xsmall,
      minHeight: tokenSchema.size.element.large,
      padding: tokenSchema.size.space.regular,
      paddingInlineStart: tokenSchema.size.space.large,
      pointerEvents: "auto",
      position: "absolute",
      color: tokenSchema.color.foreground.onEmphasis,
      "&[data-tone=neutral]": {
        background: tokenSchema.color.scale.slate9
      },
      "&[data-tone=info]": {
        background: tokenSchema.color.background.accentEmphasis
      },
      "&[data-tone=positive]": {
        background: tokenSchema.color.background.positiveEmphasis
      },
      "&[data-tone=critical]": {
        background: tokenSchema.color.background.criticalEmphasis
      }
    }), styleProps.className);
    $[13] = styleProps.className;
    $[14] = t6;
  } else {
    t6 = $[14];
  }
  let t7;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = css({
      display: "flex"
    });
    $[15] = t7;
  } else {
    t7 = $[15];
  }
  let t8;
  if ($[16] !== icon || $[17] !== iconLabel) {
    t8 = icon && /*#__PURE__*/jsx(Icon, {
      "aria-label": iconLabel,
      src: icon,
      size: "medium",
      marginTop: "small",
      marginEnd: "regular"
    });
    $[16] = icon;
    $[17] = iconLabel;
    $[18] = t8;
  } else {
    t8 = $[18];
  }
  let t9;
  if ($[19] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = classNames(css({
      alignItems: "center",
      display: "flex",
      columnGap: tokenSchema.size.space.large,
      flex: 1,
      flexWrap: "wrap",
      justifyContent: "flex-end",
      paddingInlineEnd: tokenSchema.size.space.large
    }));
    $[19] = t9;
  } else {
    t9 = $[19];
  }
  let t10;
  if ($[20] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = classNames(css({
      flexGrow: 1,
      paddingBlock: tokenSchema.size.space.regular
    }));
    $[20] = t10;
  } else {
    t10 = $[20];
  }
  let t11;
  if ($[21] !== children) {
    t11 = isReactText(children) ? /*#__PURE__*/jsx(Text, {
      children: children
    }) : children;
    $[21] = children;
    $[22] = t11;
  } else {
    t11 = $[22];
  }
  let t12;
  if ($[23] !== titleProps || $[24] !== t11) {
    t12 = /*#__PURE__*/jsx("div", {
      className: t10,
      ...titleProps,
      children: t11
    });
    $[23] = titleProps;
    $[24] = t11;
    $[25] = t12;
  } else {
    t12 = $[25];
  }
  let t13;
  if ($[26] !== actionLabel || $[27] !== handleAction) {
    t13 = actionLabel && /*#__PURE__*/jsx(Button, {
      onPress: handleAction,
      static: "light",
      children: actionLabel
    });
    $[26] = actionLabel;
    $[27] = handleAction;
    $[28] = t13;
  } else {
    t13 = $[28];
  }
  let t14;
  if ($[29] !== t12 || $[30] !== t13) {
    t14 = /*#__PURE__*/jsxs("div", {
      className: t9,
      children: [t12, t13]
    });
    $[29] = t12;
    $[30] = t13;
    $[31] = t14;
  } else {
    t14 = $[31];
  }
  let t15;
  if ($[32] !== contentProps || $[33] !== t8 || $[34] !== t14) {
    t15 = /*#__PURE__*/jsxs("div", {
      ...contentProps,
      className: t7,
      children: [t8, t14]
    });
    $[32] = contentProps;
    $[33] = t8;
    $[34] = t14;
    $[35] = t15;
  } else {
    t15 = $[35];
  }
  let t16;
  if ($[36] === Symbol.for("react.memo_cache_sentinel")) {
    t16 = css({
      borderInlineStart: `${tokenSchema.size.border.regular} solid #fff3`,
      paddingInlineStart: tokenSchema.size.space.regular
    });
    $[36] = t16;
  } else {
    t16 = $[36];
  }
  let t17;
  if ($[37] !== closeButtonProps) {
    t17 = /*#__PURE__*/jsx("div", {
      className: t16,
      children: /*#__PURE__*/jsx(ClearButton, {
        static: "light",
        ...closeButtonProps
      })
    });
    $[37] = closeButtonProps;
    $[38] = t17;
  } else {
    t17 = $[38];
  }
  let t18;
  if ($[39] !== t15 || $[40] !== t17) {
    t18 = /*#__PURE__*/jsxs(SlotProvider, {
      slots: slots,
      children: [t15, t17]
    });
    $[39] = t15;
    $[40] = t17;
    $[41] = t18;
  } else {
    t18 = $[41];
  }
  let t19;
  if ($[42] !== styleProps || $[43] !== toastProps || $[44] !== domRef || $[45] !== tone || $[46] !== t6 || $[47] !== t18) {
    t19 = /*#__PURE__*/jsx("div", {
      ...styleProps,
      ...toastProps,
      ref: domRef,
      "data-tone": tone,
      className: t6,
      style: styleProps.style,
      children: t18
    });
    $[42] = styleProps;
    $[43] = toastProps;
    $[44] = domRef;
    $[45] = tone;
    $[46] = t6;
    $[47] = t18;
    $[48] = t19;
  } else {
    t19 = $[48];
  }
  return t19;
}
let _Toast = /*#__PURE__*/forwardRef(Toast);

/** @private Positioning and provider for toast children. */
function ToastContainer(props) {
  const $ = c(11);
  const {
    children,
    state
  } = props;
  const {
    direction
  } = useLocale();
  const isMobileDevice = useIsMobileDevice();
  const placement = isMobileDevice ? "center" : props.placement || "end";
  const position = isMobileDevice ? "bottom" : props.position || "bottom";
  const ref = useRef(null);
  const {
    regionProps
  } = useToastRegion(props, state, ref);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {
      background: "transparent"
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = css({
      display: "flex",
      insetInline: 0,
      outline: "none",
      pointerEvents: "none",
      position: "fixed",
      zIndex: 100,
      "&[data-focus=visible] > :first-child:after": {
        borderRadius: `calc(${tokenSchema.size.radius.regular} + ${tokenSchema.size.alias.focusRingGap})`,
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
        content: "\"\"",
        inset: 0,
        margin: `calc(-1 * ${tokenSchema.size.alias.focusRingGap})`,
        pointerEvents: "none",
        position: "absolute"
      },
      "&[data-position=top]": {
        top: 0,
        flexDirection: "column",
        "--slide-from": "translateY(-100%)",
        "--slide-to": "translateY(0)"
      },
      "&[data-position=bottom]": {
        bottom: 0,
        flexDirection: "column-reverse",
        "--slide-from": "translateY(100%)",
        "--slide-to": "translateY(0)"
      },
      "&[data-placement=start]": {
        alignItems: "flex-start",
        "--slide-from": "translateX(-100%)",
        "--slide-to": "translateX(0)",
        "&[data-direction=rtl]": {
          "--slide-from": "translateX(100%)"
        }
      },
      "&[data-placement=center]": {
        alignItems: "center"
      },
      "&[data-placement=end]": {
        alignItems: "flex-end",
        "--slide-from": "translateX(100%)",
        "--slide-to": "translateX(0)",
        "&[data-direction=rtl]": {
          "--slide-from": "translateX(-100%)"
        }
      }
    });
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== regionProps || $[3] !== ref || $[4] !== direction || $[5] !== position || $[6] !== placement || $[7] !== children) {
    t2 = /*#__PURE__*/jsx(KeystarProvider, {
      UNSAFE_style: t0,
      children: /*#__PURE__*/jsx(FocusRing, {
        children: /*#__PURE__*/jsx("div", {
          ...regionProps,
          ref: ref,
          "data-direction": direction,
          "data-position": position,
          "data-placement": placement,
          className: t1,
          children: children
        })
      })
    });
    $[2] = regionProps;
    $[3] = ref;
    $[4] = direction;
    $[5] = position;
    $[6] = placement;
    $[7] = children;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  const contents = t2;
  let t3;
  if ($[9] !== contents) {
    t3 = /*#__PURE__*/ReactDOM.createPortal(contents, document.body);
    $[9] = contents;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  return t3;
}

// There is a single global toast queue instance for the whole app, initialized lazily.
let globalToastQueue = null;
function getGlobalToastQueue() {
  if (!globalToastQueue) {
    globalToastQueue = new ToastQueue({
      maxVisibleToasts: 1
    });
  }
  return globalToastQueue;
}
let toastProviders = new Set();
let subscriptions = new Set();
function subscribe(fn) {
  subscriptions.add(fn);
  return () => subscriptions.delete(fn);
}
function getActiveToaster() {
  return toastProviders.values().next().value;
}
function useActiveToaster() {
  return useSyncExternalStore(subscribe, getActiveToaster, getActiveToaster);
}

/**
 * A Toaster renders the queued toasts in an application. It should be
 * placed at the root of the app.
 */
function Toaster(props) {
  const $ = c(10);
  const ref = useRef(null);
  toastProviders.add(ref);
  let t0;
  if ($[0] !== ref) {
    t0 = () => () => {
      toastProviders.delete(ref);
      for (const fn of subscriptions) {
        fn();
      }
    };
    $[0] = ref;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [];
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  useEffect(t0, t1);
  const activeToaster = useActiveToaster();
  let t2;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = getGlobalToastQueue();
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const state = useToastQueue(t2);
  if (ref === activeToaster && state.visibleToasts.length > 0) {
    let t3;
    if ($[4] !== state) {
      t3 = state.visibleToasts.map(toast => /*#__PURE__*/jsx(_Toast, {
        toast: toast,
        state: state
      }, toast.key));
      $[4] = state;
      $[5] = t3;
    } else {
      t3 = $[5];
    }
    let t4;
    if ($[6] !== state || $[7] !== props || $[8] !== t3) {
      t4 = /*#__PURE__*/jsx(ToastContainer, {
        state: state,
        ...props,
        children: t3
      });
      $[6] = state;
      $[7] = props;
      $[8] = t3;
      $[9] = t4;
    } else {
      t4 = $[9];
    }
    return t4;
  }
  return null;
}
function addToast(children, tone, options = {}) {
  // Dispatch a custom event so that toasts can be intercepted and re-targeted, e.g. when inside an iframe.
  if (typeof CustomEvent !== 'undefined' && typeof window !== 'undefined') {
    let event = new CustomEvent('keystar-ui-toast', {
      cancelable: true,
      bubbles: true,
      detail: {
        children,
        tone,
        options
      }
    });
    let shouldContinue = window.dispatchEvent(event);
    if (!shouldContinue) {
      return () => {};
    }
  }
  let value = {
    children,
    tone,
    actionLabel: options.actionLabel,
    onAction: options.onAction,
    shouldCloseOnAction: options.shouldCloseOnAction
  };
  warning(typeof options.timeout === 'number' && options.timeout >= 5000, 'Timeouts must be at least 5000ms, for accessibility.');
  let timeout = options.timeout ? Math.max(options.timeout, 5000) : undefined;
  let queue = getGlobalToastQueue();
  let key = queue.add(value, {
    timeout,
    onClose: options.onClose
  });
  return () => queue.close(key);
}
const toastQueue = {
  /** Queues a neutral toast. */
  neutral(children, options = {}) {
    return addToast(children, 'neutral', options);
  },
  /** Queues a positive toast. */
  positive(children, options = {}) {
    return addToast(children, 'positive', options);
  },
  /** Queues a critical toast. */
  critical(children, options = {}) {
    return addToast(children, 'critical', options);
  },
  /** Queues an informational toast. */
  info(children, options = {}) {
    return addToast(children, 'info', options);
  }
};

export { Toaster, toastQueue };
